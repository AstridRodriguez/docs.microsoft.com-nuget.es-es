---
title: "Resolución de dependencias de paquetes NuGet | Microsoft Docs"
author: kraigb
ms.author: kraigb
manager: ghogen
ms.date: 8/14/2017
ms.topic: article
ms.prod: nuget
ms.technology: 
ms.assetid: 1d530a72-3486-4a0d-b6fb-017524616f91
description: "Obtenga más información sobre el proceso de resolución e instalación de las dependencias de un paquete NuGet en NuGet 2.x y NuGet 3.x y versiones posteriores."
keywords: "Dependencias de paquetes NuGet, control de versiones de NuGet, versiones de dependencia, gráfico de versiones, resolución de versiones, restauración transitiva"
ms.reviewer:
- karann-msft
- unniravindranathan
ms.openlocfilehash: 44c69c07990fed72b439698d22021ebcbb2eed89
ms.sourcegitcommit: d0ba99bfe019b779b75731bafdca8a37e35ef0d9
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 12/14/2017
---
# <a name="how-nuget-resolves-package-dependencies"></a><span data-ttu-id="be190-104">Cómo resuelve NuGet las dependencias de paquetes</span><span class="sxs-lookup"><span data-stu-id="be190-104">How NuGet resolves package dependencies</span></span>

<span data-ttu-id="be190-105">Siempre que se instala o reinstala un paquete, lo que incluye la instalación como parte de un proceso de [restauración](../consume-packages/package-restore.md), NuGet también instala los paquetes adicionales de los que depende ese primer paquete.</span><span class="sxs-lookup"><span data-stu-id="be190-105">Any time a package is installed or reinstalled, which includes being installed as part of a [restore](../consume-packages/package-restore.md) process, NuGet also installs any additional packages on which that first package depends.</span></span>

<span data-ttu-id="be190-106">Es posible que esas dependencias inmediatas también tengan sus propias dependencias, lo que puede continuar hasta una profundidad arbitraria.</span><span class="sxs-lookup"><span data-stu-id="be190-106">Those immediate dependencies might then also have dependencies on their own, which can continue to an arbitrary depth.</span></span> <span data-ttu-id="be190-107">Esto produce lo que se denomina un *gráfico de dependencias*, en el que se describen las relaciones existentes entre los paquetes en todos los niveles.</span><span class="sxs-lookup"><span data-stu-id="be190-107">This produces what's called a *dependency graph* that describes the relationships between packages are all levels.</span></span>

<span data-ttu-id="be190-108">Cuando varios paquetes tienen la misma dependencia, entonces el mismo Id. de paquete puede aparecer varias veces en el gráfico, posiblemente con restricciones de versión diferentes.</span><span class="sxs-lookup"><span data-stu-id="be190-108">When multiple packages have the same dependency, then the same package ID can appear in the graph multiple times, potentially with different version constraints.</span></span> <span data-ttu-id="be190-109">Pero solo se puede usar una versión de un paquete determinado en un proyecto, por lo que NuGet debe elegir qué versión se va a usar.</span><span class="sxs-lookup"><span data-stu-id="be190-109">However, only one version of a given package can be used in a project, so NuGet must choose which version is be used.</span></span> <span data-ttu-id="be190-110">El proceso exacto depende del formato de referencia de paquete que se usa.</span><span class="sxs-lookup"><span data-stu-id="be190-110">The exact process depends on the package reference format being used.</span></span>

<span data-ttu-id="be190-111">En este tema:</span><span class="sxs-lookup"><span data-stu-id="be190-111">In this topic:</span></span>
- [<span data-ttu-id="be190-112">Resolución de dependencias con PackageReference y project.json</span><span class="sxs-lookup"><span data-stu-id="be190-112">Dependency resolution with PackageReference and project.json</span></span>](#dependency-resolution-with-packagereference-and-projectjson)
- [<span data-ttu-id="be190-113">Resolución de dependencias con packages.config</span><span class="sxs-lookup"><span data-stu-id="be190-113">Dependency resolution with packages.config</span></span>](#dependency-resolution-with-packagesconfig)
- <span data-ttu-id="be190-114">[Exclusión de referencias](#excluding-references), que es necesaria cuando hay un conflicto entre una dependencia especificada en un proyecto y un ensamblado que se genera por otro.</span><span class="sxs-lookup"><span data-stu-id="be190-114">[Excluding references](#excluding-references), which is necessary when there's a conflict between a dependency specified in one project and an assembly that's produced by another.</span></span>
- [<span data-ttu-id="be190-115">Actualizaciones de dependencias durante la instalación de paquetes</span><span class="sxs-lookup"><span data-stu-id="be190-115">Dependency updates during package install</span></span>](#dependency-updates-during-package-install)
- [<span data-ttu-id="be190-116">Resolución de errores de paquetes incompatibles</span><span class="sxs-lookup"><span data-stu-id="be190-116">Resolving incompatible package errors</span></span>](#resolving-incompatible-package-errors)

## <a name="dependency-resolution-with-packagereference-and-projectjson"></a><span data-ttu-id="be190-117">Resolución de dependencias con PackageReference y project.json</span><span class="sxs-lookup"><span data-stu-id="be190-117">Dependency resolution with PackageReference and project.json</span></span>

<span data-ttu-id="be190-118">Al instalar paquetes en proyectos que usan los formatos PackageReference o `project.json`, NuGet agrega referencias a un gráfico de paquete sin formato en el archivo adecuado y resuelve conflictos con antelación.</span><span class="sxs-lookup"><span data-stu-id="be190-118">When installing packages into projects using the PackageReference or `project.json` formats, NuGet adds references to a flat package graph in the appropriate file and resolves conflicts ahead of time.</span></span> <span data-ttu-id="be190-119">Este proceso se conoce como *restauración transitiva*.</span><span class="sxs-lookup"><span data-stu-id="be190-119">This process is referred to as *transitive restore*.</span></span> <span data-ttu-id="be190-120">La reinstalación o restauración de paquetes es un proceso de descarga de los paquetes enumerados en el gráfico, lo que produce compilaciones más rápidas y predecibles.</span><span class="sxs-lookup"><span data-stu-id="be190-120">Reinstalling or restoring packages is then a process of downloading the packages listed in the graph, resulting in faster and more predictable builds.</span></span> <span data-ttu-id="be190-121">También puede aprovechar las ventajas de las versiones comodín (flotantes), como 2.8.\*, lo que evita llamadas costosas y propensas a errores a `nuget update` en los equipos cliente y servidores de compilación.</span><span class="sxs-lookup"><span data-stu-id="be190-121">You can also take advantage of wildcard (floating) versions, such as 2.8.\*, avoiding expensive and error prone calls to `nuget update` on the client machines and build servers.</span></span>

<span data-ttu-id="be190-122">Cuando se ejecuta el proceso de restauración de NuGet antes de una compilación, primero se resuelven las dependencias en memoria y después se escribe el gráfico resultante en un archivo denominado `project.assets.json` en la carpeta `obj` de un proyecto mediante PackageReference, o bien en un archivo denominado `project.lock.json` junto con `project.json`.</span><span class="sxs-lookup"><span data-stu-id="be190-122">When the NuGet restore process runs prior to a build, it resolves dependencies first in memory, then writes the resulting graph to a file called `project.assets.json` in the `obj` folder of a project using PackageReference, or in a file named `project.lock.json` alongside `project.json`.</span></span> <span data-ttu-id="be190-123">Después, MSBuild lee este archivo y lo convierte en un conjunto de carpetas donde se pueden encontrar posibles referencias y luego se agregan al árbol del proyecto en memoria.</span><span class="sxs-lookup"><span data-stu-id="be190-123">MSBuild then reads this file and translates it into a set of folders where potential references can be found, and then adds them to the project tree in memory.</span></span>

<span data-ttu-id="be190-124">El archivo de bloqueo es temporal y no se debe agregar al control de código fuente.</span><span class="sxs-lookup"><span data-stu-id="be190-124">The lock file is temporary and should not be added to source control.</span></span> <span data-ttu-id="be190-125">Se muestra de forma predeterminada en `.gitignore` y `.tfignore`.</span><span class="sxs-lookup"><span data-stu-id="be190-125">It's listed by default in both `.gitignore` and `.tfignore`.</span></span> <span data-ttu-id="be190-126">Vea [Paquetes y control de código fuente](Packages-and-Source-Control.md).</span><span class="sxs-lookup"><span data-stu-id="be190-126">See [Packages and source control](Packages-and-Source-Control.md).</span></span>

### <a name="dependency-resolution-rules"></a><span data-ttu-id="be190-127">Reglas de resolución de dependencias</span><span class="sxs-lookup"><span data-stu-id="be190-127">Dependency resolution rules</span></span>

<span data-ttu-id="be190-128">La restauración transitiva aplica cuatro reglas principales para resolver las dependencias: la versión aplicable más baja, versiones flotantes, coincidencias más próximas y dependencias relacionadas.</span><span class="sxs-lookup"><span data-stu-id="be190-128">Transitive restore applies four main rules to resolve dependencies: lowest applicable version, floating versions, nearest-wins, and cousin dependencies.</span></span>

<a name="lowest-applicable-version"></a>

#### <a name="lowest-applicable-version"></a><span data-ttu-id="be190-129">Versión aplicable más baja</span><span class="sxs-lookup"><span data-stu-id="be190-129">Lowest applicable version</span></span>

<span data-ttu-id="be190-130">La regla de la versión aplicable más baja restaura la versión más baja posible de un paquete de acuerdo con sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="be190-130">The lowest applicable version rule restores the lowest possible version of a package as defined by its dependencies.</span></span> <span data-ttu-id="be190-131">También se aplica a las dependencias de la aplicación o la biblioteca de clases, a menos que se declaren como [flotantes](#floating-versions).</span><span class="sxs-lookup"><span data-stu-id="be190-131">It also applies to dependencies on the application or the class library unless declared as [floating](#floating-versions).</span></span>

<span data-ttu-id="be190-132">En la ilustración siguiente, por ejemplo, 1.0-beta se considera menor que 1.0, por lo que NuGet elige la versión 1.0:</span><span class="sxs-lookup"><span data-stu-id="be190-132">In the following figure, for example, 1.0-beta is considered lower than 1.0 so NuGet chooses the 1.0 version:</span></span>

![Elección de la versión aplicable más baja](media/projectJson-dependency-1.png)

<span data-ttu-id="be190-134">En la ilustración siguiente, la versión 2.1 no está disponible en la fuente, pero como la restricción de versión es >= 2.1, NuGet elige la siguiente versión más baja que puede encontrar, en este caso 2.2:</span><span class="sxs-lookup"><span data-stu-id="be190-134">In the next figure, version 2.1 is not available on the feed but because the version constraint is >= 2.1 NuGet picks the next lowest version it can find, in this case 2.2:</span></span>

![Elección de la siguiente versión más baja disponible en la fuente](media/projectJson-dependency-2.png)

<span data-ttu-id="be190-136">Cuando una aplicación especifica un número de versión exacto, como 1.2, que no está disponible en la fuente, NuGet produce un error al intentar instalar o restaurar el paquete:</span><span class="sxs-lookup"><span data-stu-id="be190-136">When an application specifies an exact version number, such as 1.2, that is not available on the feed, NuGet fails with an error when attempting to install or restore the package:</span></span>

![NuGet genera un error cuando no hay una versión de paquete exacta disponible](media/projectJson-dependency-3.png)

<a name="floating-versions"></a>

#### <a name="floating-wildcard-versions"></a><span data-ttu-id="be190-138">Versiones flotantes (comodín)</span><span class="sxs-lookup"><span data-stu-id="be190-138">Floating (wildcard) versions</span></span>

<span data-ttu-id="be190-139">Una versión de dependencia flotante o comodín se especifica con el carácter comodín \*, como en 6.0.\*.</span><span class="sxs-lookup"><span data-stu-id="be190-139">A floating or wildcard dependency version is specified with the \* wildcard, as with 6.0.\*.</span></span> <span data-ttu-id="be190-140">Esta especificación de versión dice "usar la versión 6.0.x más reciente"; 4.\* significa "usar la versión más reciente de 4.x".</span><span class="sxs-lookup"><span data-stu-id="be190-140">This version specification says "use the latest 6.0.x version"; 4.\* means "use the latest 4.x version."</span></span> <span data-ttu-id="be190-141">El uso de un carácter comodín permite que un paquete de dependencia siga evolucionando sin necesidad de un cambio en la aplicación (o paquete) que lo consume.</span><span class="sxs-lookup"><span data-stu-id="be190-141">Using a wildcard allows a dependency package to continue evolving without requiring a change to the consuming application (or package).</span></span>

<span data-ttu-id="be190-142">Cuando se usa un carácter comodín, NuGet resuelve la versión más alta de un paquete que coincide con el patrón de versión, por ejemplo 6.0.\* obtiene la versión más alta de un paquete que empieza por 6.0:</span><span class="sxs-lookup"><span data-stu-id="be190-142">When using a wildcard, NuGet resolves the highest version of a package that matches the version pattern, for example 6.0.\* gets the highest version of a package that starts with 6.0:</span></span>

![Elección de la versión 6.0.1 cuando se solicita una versión flotante 6.0.*.](media/projectJson-dependency-4.png)

> [!Note]
> <span data-ttu-id="be190-144">Para obtener información sobre el comportamiento de los caracteres comodín y versiones preliminares, vea [Control de versiones de paquetes](../reference/package-versioning.md#version-ranges-and-wildcards).</span><span class="sxs-lookup"><span data-stu-id="be190-144">For information on the behavior of wildcards and pre-release versions, see [Package versioning](../reference/package-versioning.md#version-ranges-and-wildcards).</span></span>


<a name="nearest-wins"></a>

#### <a name="nearest-wins"></a><span data-ttu-id="be190-145">Coincidencias más próximas</span><span class="sxs-lookup"><span data-stu-id="be190-145">Nearest wins</span></span>

<span data-ttu-id="be190-146">Cuando el gráfico de paquetes de una aplicación contiene versiones diferentes del mismo paquete, NuGet elige la más cercana a la aplicación en el gráfico e ignora todas las demás.</span><span class="sxs-lookup"><span data-stu-id="be190-146">When the package graph for an application contains different versions of the same package, NuGet chooses the package that's closest to the application in the graph and ignores all others.</span></span> <span data-ttu-id="be190-147">Este comportamiento permite que una aplicación invalide cualquier versión de paquete en particular en el gráfico de dependencias.</span><span class="sxs-lookup"><span data-stu-id="be190-147">This behavior allows an application to override any particular package version in the dependency graph.</span></span>

<span data-ttu-id="be190-148">En el ejemplo siguiente, la aplicación depende directamente del Paquete B con una restricción de versión de >=2.0.</span><span class="sxs-lookup"><span data-stu-id="be190-148">In the example below, the application depends directly on Package B with a version constraint of >=2.0.</span></span> <span data-ttu-id="be190-149">La aplicación también depende del Paquete A que, a su vez, depende también del Paquete B, pero con una restricción >=1.0.</span><span class="sxs-lookup"><span data-stu-id="be190-149">The application also depends on Package A which in turn also depends on Package B, but with a >=1.0 constraint.</span></span> <span data-ttu-id="be190-150">Dado que la dependencia del Paquete B 2.0 está más próxima a la aplicación en el gráfico, se usa esa versión:</span><span class="sxs-lookup"><span data-stu-id="be190-150">Because the dependency on Package B 2.0 is nearer to the application in the graph, that version is used:</span></span>

![Aplicación con la regla de coincidencias más próximas](media/projectJson-dependency-5.png)

>[!Warning]
> <span data-ttu-id="be190-152">La regla de coincidencias más próximas puede provocar el cambio a una versión anterior del paquete, lo que podría afectar a otras dependencias del gráfico.</span><span class="sxs-lookup"><span data-stu-id="be190-152">The Nearest Wins rule can result in a downgrade of the package version, thus potentially breaking other dependencies in the graph.</span></span> <span data-ttu-id="be190-153">Por tanto, esta regla se aplica con una advertencia para avisar al usuario.</span><span class="sxs-lookup"><span data-stu-id="be190-153">Hence this rule is applied with a warning to alert the user.</span></span>

<span data-ttu-id="be190-154">Esta regla también consigue mayor eficacia con un gráfico de dependencias de gran tamaño (por ejemplo, aquellos con los paquetes BCL) porque una vez que se ignora una dependencia concreta, NuGet también ignora todas las dependencias restantes en esa rama del gráfico.</span><span class="sxs-lookup"><span data-stu-id="be190-154">This rule also results in greater efficiency with a large dependency graph (such as those with the BCL packages) because once a given dependency is ignored, NuGet also ignores all remaining dependencies on that branch of the graph.</span></span> <span data-ttu-id="be190-155">En el diagrama siguiente, por ejemplo, como se usa el paquete C 2.0, NuGet ignora las ramas en el gráfico que hacen referencia a una versión anterior del Paquete C:</span><span class="sxs-lookup"><span data-stu-id="be190-155">In the diagram below, for example, because Package C 2.0 is used, NuGet ignores any branches in the graph that refer to an older version of Package C:</span></span>

![Cuando NuGet ignora un paquete en el gráfico, ignora esa rama completa](media/projectJson-dependency-6.png)

<a name="cousin-dependencies"></a>

#### <a name="cousin-dependencies"></a><span data-ttu-id="be190-157">Dependencias relacionadas</span><span class="sxs-lookup"><span data-stu-id="be190-157">Cousin dependencies</span></span>

<span data-ttu-id="be190-158">Cuando se hace referencia a versiones diferentes del paquete a la misma distancia en el gráfico de la aplicación, NuGet usa la versión más baja que cumpla todos los requisitos de versión (como sucede con las reglas de [versión aplicable más baja](#lowest-applicable-version) y [versiones flotantes](#floating-versions)).</span><span class="sxs-lookup"><span data-stu-id="be190-158">When different package versions are referred to at the same distance in the graph from the application, NuGet uses the lowest version that satisfies all version requirements (as with the [lowest applicable version](#lowest-applicable-version) and [floating versions](#floating-versions) rules).</span></span> <span data-ttu-id="be190-159">En la imagen siguiente, por ejemplo, la versión 2.0 del Paquete B satisface la otra restricción >=1.0 y, por tanto, es la que se usa:</span><span class="sxs-lookup"><span data-stu-id="be190-159">In the image below, for example, version 2.0 of Package B satisfies the other >=1.0 constraint, and is thus used:</span></span>

![Resolución de dependencias relacionadas con la versión más baja que cumple todas las restricciones](media/projectJson-dependency-7.png)

<span data-ttu-id="be190-161">En algunos casos, no es posible cumplir todos los requisitos de versión.</span><span class="sxs-lookup"><span data-stu-id="be190-161">In some cases, it is not possible to meet all version requirements.</span></span> <span data-ttu-id="be190-162">Como se muestra a continuación, si el Paquete A requiere exactamente el Paquete B 1.0 y el Paquete C requiere el Paquete B >=2.0, NuGet no puede resolver las dependencias y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="be190-162">As shown below, if Package A requires exactly Package B 1.0 and Package C requires Package B >=2.0, then NuGet cannot resolve the dependencies and gives an error.</span></span>

![Dependencias que no se pueden resolver debido a un requisito de versión exacta](media/projectJson-dependency-8.png)

<span data-ttu-id="be190-164">En estas situaciones, el consumidor de nivel superior (la aplicación o el paquete) debe agregar su propia dependencia directa en el Paquete B para que se aplique la regla de [coincidencias más próximas](#nearest-wins).</span><span class="sxs-lookup"><span data-stu-id="be190-164">In these situations, the top-level consumer (the application or package) should add its own direct dependency on Package B so that the [Nearest Wins](#nearest-wins) rule applies.</span></span>

## <a name="dependency-resolution-with-packagesconfig"></a><span data-ttu-id="be190-165">Resolución de dependencias con packages.config</span><span class="sxs-lookup"><span data-stu-id="be190-165">Dependency resolution with packages.config</span></span>

<span data-ttu-id="be190-166">Con `packages.config`, las dependencias de un proyecto se escriben en `packages.config` como una lista plana.</span><span class="sxs-lookup"><span data-stu-id="be190-166">With `packages.config`, a project's dependencies are written to `packages.config` as a flat list.</span></span> <span data-ttu-id="be190-167">Todas las dependencias de esos paquetes también se escriben en la misma lista.</span><span class="sxs-lookup"><span data-stu-id="be190-167">Any dependencies of those packages are also written in the same list.</span></span> <span data-ttu-id="be190-168">Cuando se instalan paquetes, es posible que NuGet también modifique el archivo `.csproj`, `app.config`, `web.config` y otros archivos individuales.</span><span class="sxs-lookup"><span data-stu-id="be190-168">When packages are installed, NuGet might also modify the `.csproj` file, `app.config`, `web.config`, and other individual files.</span></span>

<span data-ttu-id="be190-169">Con `packages.config`, NuGet intenta resolver los conflictos de dependencias durante la instalación de cada paquete individual.</span><span class="sxs-lookup"><span data-stu-id="be190-169">With `packages.config`, NuGet attempts to resolve dependency conflicts during the installation of each individual package.</span></span> <span data-ttu-id="be190-170">Es decir, si se está instalando el Paquete A y depende del Paquete B, y el Paquete B ya aparece en `packages.config` como una dependencia de algo más, NuGet compara las versiones del Paquete B que se solicitan e intenta buscar una versión que satisfaga todas las restricciones de versión.</span><span class="sxs-lookup"><span data-stu-id="be190-170">That is, if Package A is being installed and depends on Package B, and Package B is already listed in `packages.config` as a dependency of something else, NuGet compares the versions of Package B being requested and attempts to find a version that satisfies all version constraints.</span></span> <span data-ttu-id="be190-171">En concreto, NuGet selecciona la versión *principal.secundaria* más baja que cumpla las dependencias.</span><span class="sxs-lookup"><span data-stu-id="be190-171">Specifically, NuGet selects the lower *major.minor* version that satisfies dependencies.</span></span>

<span data-ttu-id="be190-172">De forma predeterminada, en NuGet 2.7 y versiones anteriores se resuelve la versión de *revisión* más alta (mediante la convención *principal.secundaria.revisión.compilación*).</span><span class="sxs-lookup"><span data-stu-id="be190-172">By default, NuGet 2.7 and earlier resolves the highest *patch* version (using the *major.minor.patch.build* convention).</span></span> <span data-ttu-id="be190-173">En [NuGet 2.8 y versiones posteriores](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies) se cambia este comportamiento para buscar la versión de revisión más antigua de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="be190-173">[NuGet 2.8 and higher](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies) changes this behavior to look for the lowest patch version by default.</span></span> <span data-ttu-id="be190-174">Puede controlar esta configuración mediante el atributo `DependencyVersion` de `Nuget.Config` y el modificador `-DependencyVersion` en la línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="be190-174">You can control this setting through the `DependencyVersion` attribute in `Nuget.Config` and the `-DependencyVersion` switch on the command line.</span></span>  

<span data-ttu-id="be190-175">El proceso de `packages.config` para resolver dependencias se complica en gráficos de dependencias más grandes.</span><span class="sxs-lookup"><span data-stu-id="be190-175">The `packages.config` process for resolving dependencies gets complicated for larger dependency graphs.</span></span> <span data-ttu-id="be190-176">En cada instalación de un paquete nuevo es necesario recorrer el gráfico completo y aumenta la posibilidad de conflictos de versiones.</span><span class="sxs-lookup"><span data-stu-id="be190-176">Each new package installation requires a traversal of the whole graph and raises the chance for version conflicts.</span></span> <span data-ttu-id="be190-177">Cuando se produce un conflicto, la instalación se detiene, lo que deja el proyecto en un estado indeterminado, especialmente con posibles modificaciones del propio archivo de proyecto.</span><span class="sxs-lookup"><span data-stu-id="be190-177">When a conflict occurs, installation is stopped, leaving the project in an indeterminate state, especially with potential modifications to the project file itself.</span></span> <span data-ttu-id="be190-178">Esto no es un problema al usar otros formatos de referencia de paquetes.</span><span class="sxs-lookup"><span data-stu-id="be190-178">This is not an issue when using other package reference formats.</span></span>


## <a name="managing-dependency-assets"></a><span data-ttu-id="be190-179">Administración de recursos de dependencia</span><span class="sxs-lookup"><span data-stu-id="be190-179">Managing dependency assets</span></span>

<span data-ttu-id="be190-180">Cuando se usa `project.json` o formatos PackageReference, se puede controlar qué activos de dependencias fluyen al proyecto de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="be190-180">When using the `project.json` or PackageReference formats, you can control which assets from dependencies flow into the top-level project.</span></span> <span data-ttu-id="be190-181">Para obtener más información, vea [project.json](../Schema/project-json.md) y [Referencias de paquetes en archivos de proyecto](Package-References-in-Project-Files.md#controlling-dependency-assets).</span><span class="sxs-lookup"><span data-stu-id="be190-181">For details, see [project.json](../Schema/project-json.md) and [Package references in project files](Package-References-in-Project-Files.md#controlling-dependency-assets).</span></span>

<span data-ttu-id="be190-182">Cuando el proyecto de nivel superior es un paquete, también tiene control sobre este flujo mediante los atributos `include` y `exclude` con las dependencias enumeradas en el archivo `.nuspec`.</span><span class="sxs-lookup"><span data-stu-id="be190-182">When the top-level project is itself a package, you also have control over this flow by using the `include` and `exclude` attributes with dependencies listed in the `.nuspec` file.</span></span> <span data-ttu-id="be190-183">Vea [Referencia de .nuspec: dependencias](../Schema/nuspec.md#dependencies).</span><span class="sxs-lookup"><span data-stu-id="be190-183">See [.nuspec Reference - Dependencies](../Schema/nuspec.md#dependencies).</span></span>

## <a name="excluding-references"></a><span data-ttu-id="be190-184">Exclusión de referencias</span><span class="sxs-lookup"><span data-stu-id="be190-184">Excluding references</span></span>

<span data-ttu-id="be190-185">Hay escenarios en los que es posible que se haga referencia a ensamblados con el mismo nombre más de una vez en un proyecto, lo que produce errores de tiempo de diseño y tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="be190-185">There are scenarios in which assemblies with the same name might be referenced more than once in a project, producing design-time and build-time errors.</span></span> <span data-ttu-id="be190-186">Considere la posibilidad de un proyecto que contiene una versión personalizada de `C.dll` y hace referencia al Paquete C que también contiene `C.dll`.</span><span class="sxs-lookup"><span data-stu-id="be190-186">Consider a project that contains a custom version of `C.dll`, and references Package C that also contains `C.dll`.</span></span> <span data-ttu-id="be190-187">Al mismo tiempo, el proyecto también depende del Paquete B que depende también del Paquete C y `C.dll`.</span><span class="sxs-lookup"><span data-stu-id="be190-187">At the same time, the project also depends on Package B which also depends on Package C and `C.dll`.</span></span> <span data-ttu-id="be190-188">Como resultado, NuGet no puede determinar qué `C.dll` usar, pero no se puede quitar la dependencia del proyecto del Paquete C porque el Paquete B también depende de ella.</span><span class="sxs-lookup"><span data-stu-id="be190-188">As a result, NuGet can't determine which `C.dll` to use, but you can't just remove the project's dependency on Package C because Package B also depends on it.</span></span>

<span data-ttu-id="be190-189">Para resolver este problema, debe hacer referencia directamente al archivo `C.dll` que quiere (o bien usar otro paquete que haga referencia al archivo correcto) y, después, agregar una dependencia al Paquete C que excluya todos sus activos.</span><span class="sxs-lookup"><span data-stu-id="be190-189">To resolve this, you must directly reference the `C.dll` you want (or use another package that references the right one), and then add a dependency on Package C that excludes all its assets.</span></span> <span data-ttu-id="be190-190">Esto se realiza como se indica a continuación según el formato de referencia de paquete en uso:</span><span class="sxs-lookup"><span data-stu-id="be190-190">This is done as follows depending on the package reference format in use:</span></span>

- <span data-ttu-id="be190-191">[PackageReference](../consume-packages/package-references-in-project-files.md): agregue `Exclude="All"` en la dependencia:</span><span class="sxs-lookup"><span data-stu-id="be190-191">[PackageReference](../consume-packages/package-references-in-project-files.md): add `Exclude="All"` in the dependency:</span></span>

    ```xml
    <PackageReference Include="PackageC" Version="1.0.0" Exclude="All" />
    ```

- <span data-ttu-id="be190-192">`packages.config`: quite la referencia a PackageC desde el archivo `.csproj` para que solo haga referencia a la versión de `C.dll` que quiera.</span><span class="sxs-lookup"><span data-stu-id="be190-192">`packages.config`: remove the reference to PackageC from the `.csproj` file so that it references only the version of `C.dll` that you want.</span></span>
    
- <span data-ttu-id="be190-193">`project.json`: agregue `"exclude" : "all"` en la dependencia para PackageC:</span><span class="sxs-lookup"><span data-stu-id="be190-193">`project.json`: add `"exclude" : "all"` in the dependency for PackageC:</span></span>

    ```json
    {
        "dependencies": {
            "PackageC": {
            "version": "1.0.0",
            "exclude": "all"
            }
        }
    }
    ```

## <a name="dependency-updates-during-package-install"></a><span data-ttu-id="be190-194">Actualizaciones de dependencias durante la instalación de paquetes</span><span class="sxs-lookup"><span data-stu-id="be190-194">Dependency updates during package install</span></span> 

<span data-ttu-id="be190-195">Con NuGet 2.4.x y versiones anteriores, cuando se instala un paquete cuya dependencia ya existe en el proyecto, la dependencia se actualiza a la versión más reciente que cumple las restricciones de versión, incluso si la versión existente también cumple esas restricciones.</span><span class="sxs-lookup"><span data-stu-id="be190-195">With NuGet 2.4.x and earlier, when a package is installed whose dependency already exists in the project, the dependency is updated to the latest version that satisfies the version constraints, even if the existing version also satisfies those constraints.</span></span> 

<span data-ttu-id="be190-196">Por ejemplo, considere la posibilidad del Paquete A que depende del Paquete B y especifica 1.0 para el número de versión.</span><span class="sxs-lookup"><span data-stu-id="be190-196">For example, consider package A that depends on package B and specifies 1.0 for the version number.</span></span> <span data-ttu-id="be190-197">El repositorio de origen contiene las versiones 1.0, 1.1 y 1.2 del Paquete B. Si se instala A en un proyecto que ya contiene la versión 1.0 de B, B se actualiza a la versión 1.2.</span><span class="sxs-lookup"><span data-stu-id="be190-197">The source repository contains both versions 1.0, 1.1, and 1.2 of package B. If A is installed in a project that already contains B version 1.0, then B is updated to version 1.2.</span></span> 

<span data-ttu-id="be190-198">Con NuGet 2.5 y versiones posteriores, si ya se cumple una versión de dependencia, la dependencia no se actualiza durante las instalaciones de otros paquetes.</span><span class="sxs-lookup"><span data-stu-id="be190-198">With NuGet 2.5 and later, if a dependency version is already satisfied, the dependency isn't updated during other package installations.</span></span> 

<span data-ttu-id="be190-199">En el mismo ejemplo anterior, al instalar el Paquete A en un proyecto con NuGet 2.5 y versiones posteriores se mantiene el Paquete B 1.0 en el proyecto, dado que ya cumple la restricción de versión.</span><span class="sxs-lookup"><span data-stu-id="be190-199">In the same example above, installing package A into a project with NuGet 2.5 and later leaves package B 1.0 in the project, as it already satisfies the version constraint.</span></span> <span data-ttu-id="be190-200">Pero si el paquete A ha solicitado la versión 1.1 o posterior de B, debería instalarse B 1.2.</span><span class="sxs-lookup"><span data-stu-id="be190-200">However, if package A had requests version 1.1 or higher of B, then B 1.2 would be installed.</span></span> 

## <a name="resolving-incompatible-package-errors"></a><span data-ttu-id="be190-201">Resolución de errores de paquetes incompatibles</span><span class="sxs-lookup"><span data-stu-id="be190-201">Resolving incompatible package errors</span></span>

<span data-ttu-id="be190-202">Durante la operación de restauración de un paquete, puede aparecer el error "Uno o más paquetes no son compatibles..." o que un paquete "no es compatible" con la plataforma de destino del proyecto.</span><span class="sxs-lookup"><span data-stu-id="be190-202">During a package restore operation, you may see the error "One or more packages are not compatible..." or that a package "is not compatible" with the project's target framework.</span></span>

<span data-ttu-id="be190-203">Este error se produce cuando uno o varios de los paquetes a los que se hace referencia en el proyecto no indican que admiten la plataforma de destino del proyecto; es decir, el paquete no contiene un archivo DLL adecuado en su carpeta `lib` para una plataforma de destino compatible con el proyecto.</span><span class="sxs-lookup"><span data-stu-id="be190-203">This error occurs when one or more of the packages referenced in your project do not indicate that they support the project's target framework; that is, the package does not contain a suitable DLL in its `lib` folder for a target framework that is compatible with the project.</span></span> <span data-ttu-id="be190-204">(Vea [Plataformas de destino](../Schema/Target-Frameworks.md) para obtener una lista).</span><span class="sxs-lookup"><span data-stu-id="be190-204">(See [Target frameworks](../Schema/Target-Frameworks.md) for a list.)</span></span> 

<span data-ttu-id="be190-205">Por ejemplo, si un proyecto tiene como destino `netstandard1.6` e intenta instalar un paquete que solo contiene los archivos DLL en las carpetas `lib\net20` y `\lib\net45`, entonces verá mensajes similares a los siguientes para el paquete y, posiblemente, sus elementos dependientes:</span><span class="sxs-lookup"><span data-stu-id="be190-205">For example, if a project targets `netstandard1.6` and you attempt to install a package that contains DLLs in only the `lib\net20` and `\lib\net45` folders, then you'll see messages like the following for the package and possibly its dependents:</span></span>

```output
Restoring packages for myproject.csproj...
Package ContosoUtilities 2.1.2.3 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoUtilities 2.1.2.3 supports:
  - net20 (.NETFramework,Version=v2.0)
  - net45 (.NETFramework,Version=v4.5)
Package ContosoCore 0.86.0 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoCore 0.86.0 supports:
  - 11 (11,Version=v0.0)
  - net20 (.NETFramework,Version=v2.0)
  - sl3 (Silverlight,Version=v3.0)
  - sl4 (Silverlight,Version=v4.0)
One or more packages are incompatible with .NETStandard,Version=v1.6.
Package restore failed. Rolling back package changes for 'MyProject'.
```

<span data-ttu-id="be190-206">Para resolver las incompatibilidades, siga estos pasos:</span><span class="sxs-lookup"><span data-stu-id="be190-206">To resolve incompatibilities, do one of the following:</span></span>

- <span data-ttu-id="be190-207">Redestine el proyecto a una plataforma que sea compatible con los paquetes que quiere usar.</span><span class="sxs-lookup"><span data-stu-id="be190-207">Retarget your project to a framework that is supported by the packages you want to use.</span></span>
- <span data-ttu-id="be190-208">Póngase en contacto con los autores de los paquetes y trabaje con ellos para agregar compatibilidad para la plataforma seleccionada.</span><span class="sxs-lookup"><span data-stu-id="be190-208">Contact the author of the packages and work with them to add support for your chosen framework.</span></span> <span data-ttu-id="be190-209">En las páginas de lista de paquetes de [nuget.org](https://www.nuget.org/) se incluye un vínculo **Póngase en contacto con el propietario** para este propósito.</span><span class="sxs-lookup"><span data-stu-id="be190-209">Each package listing page on [nuget.org](https://www.nuget.org/) has a **Contact Owners** link for this purpose.</span></span>
- <span data-ttu-id="be190-210">**No se recomienda**: como solución temporal mientras trabaja con el autor del paquete, los proyectos destinados a `netcore`, `netstandard` y `netcoreapp` pueden indicar otras plataformas como compatibles, lo que permite que se usen los paquetes destinados a esas otras plataformas.</span><span class="sxs-lookup"><span data-stu-id="be190-210">**Not recommended**: as a temporary solution while you work with the package author, projects targeting `netcore`, `netstandard`, and `netcoreapp` can denote other frameworks as being compatible, thereby allowing packages targeting those other frameworks to be used.</span></span> <span data-ttu-id="be190-211">Vea [Importaciones de project.json](../Schema/project-json.md#imports) y [Destino de restauración de MSBuild PackageTargetFallback](../Schema/msbuild-targets.md#packagetargetfallback).</span><span class="sxs-lookup"><span data-stu-id="be190-211">See [project.json imports](../Schema/project-json.md#imports) and [MSBuild restore target PackageTargetFallback](../Schema/msbuild-targets.md#packagetargetfallback).</span></span> <span data-ttu-id="be190-212">Esto puede provocar comportamientos inesperados, por lo que de nuevo, es mejor resolver las incompatibilidades del paquete trabajando con el autor del paquete en una actualización.</span><span class="sxs-lookup"><span data-stu-id="be190-212">This can cause unexpected behaviors, so again, it's best to resolve package incompatibilities by working with the package author on an update.</span></span>
